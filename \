// $SOURCE$
//------------------------------------------------------------------------------------------------
//                      CalibrateSigmailzedResiduals functions realisations
//------------------------------------------------------------------------------------------------
// CalibrateSigmalizedResiduals
//
// ** Free and open code for anyone to use **
//
// Author: Sergei Antsupov
// Email: antsupov0124@gmail.com
//
/**
 * Basic code for calibrating sigmalized residuals (sdphi, sdz)
 **/
//------------------------------------------------------------------------------------------------

#ifndef CALIBRATE_SIGMALIZED_RESIDUALS_CPP
#define CALIBRATE_SIGMALIZED_RESIDUALS_CPP

#include "../include/CalibrateSigmalizedResiduals.hpp"

int main(int argc, char **argv)
{
   if (argc != 2)
   {
      PrintError("Expected 1 parameters while " + std::to_string(argc - 1) + " were provided");
   }
   
   InputJSONReader inputJSONContents{argv[1], "main"};
   inputJSONContents.CheckStatus("main");
   
   const std::string runName = inputJSONContents["run_name"].asString();

   if (inputJSONContents["uncalibrated_sigmalized_residuals_detectors"].size() == 0)
   {
      PrintInfo("No detectors are specified for calibrations");
      PrintInfo("Exiting the program");
      exit(1);
   }

   if (!inputJSONContents["is_pp"].asBool())
   {
      Par.centralityMin = inputJSONContents["centrality_min"].asDouble();
      Par.centralityMax = inputJSONContents["centrality_max"].asDouble();
      Par.centralityNBins = ceil((Par.centralityMax - Par.centralityMin)/5.);
   }
   else
   {
      Par.centralityMin = 0.;
      Par.centralityMax = 100.;
      Par.centralityNBins = 1.;
   }

   ROOT::EnableImplicitMT();
   ROOT::EnableThreadSafety();
   gErrorIgnoreLevel = kWarning;
   gStyle->SetOptStat(0);
   gStyle->SetOptFit(0);

   ProgressBar pBar("WAVE");
   
   const unsigned long numberOfIterations = 
      inputJSONContents["uncalibrated_sigmalized_residuals_detectors"].size()*
      Par.zDCMin.size()*4.;
   Print(numberOfIterations);
   
   unsigned long nCalls = 0.;

   const std::string inputFileName = "data/Real/" + runName + "/SingleTrack/sum.root";

   for (const auto& detector : 
        inputJSONContents["uncalibrated_sigmalized_residuals_detectors"])
   {
      const std::string outputDir = "output/ResidualCal/" + runName + 
                                    "/" + detector["name"].asString() + "/";
      system(("mkdir -p " + outputDir).c_str());
   }

   TFile inputFile(inputFileName.c_str(), "READ");

   Par.texText.SetTextFont(52);
   Par.texText.SetTextSize(0.06);

   for (const auto& detector : 
        inputJSONContents["uncalibrated_sigmalized_residuals_detectors"])
   {
      const std::string outputDir = "output/ResidualCal/" + runName + 
                                    "/" + detector["name"].asString() + "/";
      
      for (const std::string& dValName : std::vector<std::string>{"dz", "dphi"})
      {
         for (const bool isPositive : std::vector<bool>{true, false})
         {
            std::vector<TGraphErrors> grVMeans, grVSigmas;
            
            for (unsigned long i = 0; i < Par.zDCMin.size(); i++)
            { 
               Print("bruh");
               pBar.Print(static_cast<double>(nCalls)/static_cast<double>(numberOfIterations));
               nCalls++;
               
               grVMeans.emplace_back();
               grVSigmas.emplace_back();

               grVMeans.back().SetMarkerStyle(20);
               grVSigmas.back().SetMarkerStyle(20);
               
               grVMeans.back().SetMarkerSize(0.5);
               grVSigmas.back().SetMarkerSize(0.5);

               const std::string zDCRangeName = DtoStr(Par.zDCMin[i], 0) + "<zDC<" + 
                                                DtoStr(Par.zDCMax[i], 0);
               const std::string centralityRangeName = DtoStr(Par.centralityMin, 0) + "-" + 
                                                       DtoStr(Par.centralityMax, 0) + "\\%";
               const std::string detectorName = detector["name"].asString();
               const std::string chargeName = (isPositive) ? "charge>0" : "charge<0";
               
               // name of histogram
               const std::string distrDValName = dValName + " vs pT vs centrality: " + 
                                                 detectorName + ", " + chargeName + ", " + 
                                                 zDCRangeName;
               TH3F *distrDVal = static_cast<TH3F *>(inputFile.Get(distrDValName.c_str()));
               
               std::string fitsOutputFileName = outputDir + dValName + 
                                                ((isPositive) ? "_pos" : "_neg") +
                                                "_c" + DtoStr(Par.centralityMin, 0) + 
                                                "-" + DtoStr(Par.centralityMax, 0) + 
                                                "_zDC" + DtoStr(Par.zDCMin[i], 0) + 
                                                "-" + DtoStr(Par.zDCMax[i], 0);
               
               PerformFits(distrDVal, grVMeans.back(), grVSigmas.back(), 
                           fitsOutputFileName, dValName, detector["name"].asString(),
                           zDCRangeName + " [cm]", Par.centralityMin, Par.centralityMax, 
                           chargeName);
               
            }
         }
      }
   }
}
   

void PerformFits(TH3F *hist, TGraphErrors &grMeans, TGraphErrors &grSigmas,
                 const std::string& outputFileNameNoExt, const std::string& dValName,
                 const std::string& detectorName, const std::string& zDCRangeName,
                 const double centralityMin, const double centralityMax,
                 const std::string& chargeName)
{ 
   const double minBinX = hist->GetXaxis()->GetBinLowEdge(1);
   const double maxBinX = hist->GetXaxis()->GetBinUpEdge(hist->GetXaxis()->GetNbins());
   const double binWidth = hist->GetXaxis()->GetBinWidth(1);

   const std::string centralityRangeName = DtoStr(centralityMin, 0) + "-" + 
                                          DtoStr(centralityMax, 0) + "\\%";

   TF1 fitFuncGaus("gaus", "gaus");
   fitFuncGaus.SetParameters(1., 0., binWidth*2.);
   fitFuncGaus.SetParLimits(1, Average(minBinX, minBinX, maxBinX), 
                               Average(maxBinX, maxBinX, minBinX));
   fitFuncGaus.SetParLimits(2, binWidth, Average(maxBinX, maxBinX, minBinX));
   
   TF1 fitFuncDVal("fitFunc", "gaus(0) + gaus(3)");
   fitFuncDVal.SetParameters(1., 0., binWidth*2.);
   fitFuncDVal.SetParLimits(1, Average(minBinX, minBinX, maxBinX), 
                               Average(maxBinX, maxBinX, minBinX));
   fitFuncDVal.SetParLimits(2, binWidth, Average(maxBinX, maxBinX, minBinX));
   fitFuncDVal.SetParLimits(4, minBinX, maxBinX);
   fitFuncDVal.SetParLimits(5, Average(maxBinX, maxBinX, minBinX), maxBinX);
   
   TF1 fitFuncBG("bg", "gaus");
   fitFuncBG.SetParameters(1., 0., Average(maxBinX, maxBinX, maxBinX, minBinX));
   fitFuncBG.SetParLimits(1, minBinX*2., maxBinX*2.);
   fitFuncBG.SetParLimits(2, Average(maxBinX, maxBinX, minBinX), maxBinX*2.);

   fitFuncDVal.SetLineColorAlpha(kRed+1, 0.6);
   //fitFuncDVal.SetLineWidth(2);
   fitFuncBG.SetLineColorAlpha(kGreen+1, 0.9);
   //fitFuncBG.SetLineWidth(3);
   fitFuncBG.SetLineStyle(2);
   fitFuncGaus.SetLineColorAlpha(kAzure-3, 0.9);
   //fitFuncGaus.SetLineWidth(3);
   fitFuncGaus.SetLineStyle(2);

   TCanvas canv("dval vs pT", "", Par.pTXNBins*400, Par.pTYNBins*400);
   canv.Divide(Par.pTXNBins, Par.pTYNBins);

   int iCanv = 1;
    
   for (unsigned long i = 0; i < Par.pTMin.size(); i++)
   {
      canv.cd(iCanv);
      iCanv++;
      
      TH1D *distrDValProj = hist->
         ProjectionX(((std::string) hist->GetName() + "_projX").c_str(), 
                     hist->GetYaxis()->FindBin(Par.pTMin[i] + 1e-6), 
                     hist->GetYaxis()->FindBin(Par.pTMax[i] - 1e-6),
                     hist->GetZaxis()->FindBin(centralityMin + 1e-6),
                     hist->GetZaxis()->FindBin(centralityMax - 1e-6));


      const std::string pTRangeName = DtoStr(Par.pTMin[i]) + "<pT<" + 
                                      DtoStr(Par.pTMax[i]) + " [GeV/c]";
      
      if (distrDValProj->Integral(1, distrDValProj->GetXaxis()->GetNbins()) < 
          Par.minIntegralValue) 
      {
         PrintInfo("Integral is insufficient for projection of " + dValName + ", " + 
                   detectorName + ", " + chargeName + " at " + zDCRangeName + ", " + 
                   centralityRangeName + ", " + pTRangeName);
         continue;
      }
      
      double minX = 0., maxX = -1.;
      for (int k = 1; k <= distrDValProj->GetXaxis()->GetNbins(); k++)
      {
         if (distrDValProj->GetBinContent(k) > 1e-7)
         {
            minX = distrDValProj->GetXaxis()->GetBinLowEdge(k);
            break;
         }
      }
      
      for (int k = distrDValProj->GetXaxis()->GetNbins(); k > 1; k--)
      {
         if (distrDValProj->GetBinContent(k) > 1e-7)
         {
            maxX = distrDValProj->GetXaxis()->GetBinUpEdge(k);
            break;
         }
      }
      
      if (minX > maxX) 
      {
         PrintWarning("Something wrong for projection of " + dValName + ", " + 
                      detectorName + ", " + chargeName + " at " + zDCRangeName + ", " + 
                      centralityRangeName + ", " + pTRangeName);
         continue;
      }

      distrDValProj->GetXaxis()->SetTitle(dValName.c_str());
      distrDValProj->SetTitle("");
      distrDValProj->SetTitleSize(0.06, "X");
      distrDValProj->SetTitleSize(0.06, "Y");
      distrDValProj->SetLabelSize(0.06, "X");
      distrDValProj->SetLabelSize(0.06, "Y");
 
      distrDValProj->GetXaxis()->SetRange(distrDValProj->GetXaxis()->FindBin(minX+0.01),
                                          distrDValProj->GetXaxis()->FindBin(maxX-0.01));
      
      fitFuncDVal.SetRange(minX, maxX);
      fitFuncBG.SetRange(minX, maxX);
      
      fitFuncGaus.SetParLimits(0, distrDValProj->GetMaximum()/4., distrDValProj->GetMaximum());
      fitFuncGaus.SetParLimits(4, 0., distrDValProj->GetMaximum()/1.5);
      fitFuncBG.SetParLimits(0, 0., distrDValProj->GetMaximum()/1.5);
      fitFuncGaus.SetRange(Average(minBinX, minBinX, minBinX, maxBinX), 
                           Average(maxBinX, maxBinX, maxBinX, minBinX));
      
      distrDValProj->Fit(&fitFuncGaus, "RQMBN");
      distrDValProj->Fit(&fitFuncBG, "RQMBN");

      fitFuncGaus.SetRange(minX, maxX);
      
      for (int k = 0; k < 3; k++)
      {
         fitFuncDVal.SetParameter(k, fitFuncGaus.GetParameter(k));
         fitFuncDVal.SetParameter(k + 3, fitFuncBG.GetParameter(k));
      }
      
      distrDValProj->Fit(&fitFuncDVal, "RQMBN");

      for (int k = 0; k < 3; k++)
      {
         fitFuncGaus.SetParameter(k, fitFuncDVal.GetParameter(k));
         fitFuncBG.SetParameter(k, fitFuncDVal.GetParameter(k + 3));
      }
      
      distrDValProj->SetMarkerStyle(20);
      distrDValProj->SetMarkerSize(0.7);
      distrDValProj->SetMarkerColorAlpha(kBlack, 0.8);
      distrDValProj->SetLineColorAlpha(kBlack, 0.8);
      distrDValProj->SetMaximum(distrDValProj->GetMaximum()*1.1);
      
      gPad->SetLeftMargin(0.155);
      gPad->SetBottomMargin(0.115);
      
      distrDValProj->Clone()->Draw("P");
      fitFuncDVal.Clone()->Draw("SAME");
      fitFuncBG.Clone()->Draw("SAME");
      fitFuncGaus.Clone()->Draw("SAME");

      Par.texText.DrawLatexNDC(0.16, 0.85, pTRangeName.c_str());
      Par.texText.DrawLatexNDC(0.16, 0.75, zDCRangeName.c_str());
      Par.texText.DrawLatexNDC(0.8, 0.85, centralityRangeName.c_str());
      
      grMeans.AddPoint(Average(Par.pTMin[i], Par.pTMax[i]), fitFuncDVal.GetParameter(1));
      grMeans.SetPointError(grMeans.GetN() - 1, fitFuncDVal.GetParError(1));
      grSigmas.AddPoint(Average(Par.pTMin[i], Par.pTMax[i]), fitFuncDVal.GetParameter(2));
      grSigmas.SetPointError(grSigmas.GetN() - 1, fitFuncDVal.GetParError(2));
   }

   if (grMeans.GetN() == 0) 
   {
      PrintError("Graph is empty for " + dValName + ", " + detectorName + ", " + 
                 chargeName + " at " + zDCRangeName + ", " + centralityRangeName);
   }

   PrintCanvas(&canv, outputFileNameNoExt);
}

#endif /* CALIBRATE_SIGMALIZED_RESIDUALS_CPP */
